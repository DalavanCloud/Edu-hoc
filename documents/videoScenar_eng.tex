\documentclass[12pt,titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage{a4wide}
\usepackage{graphicx}
\usepackage[british]{babel}
\usepackage{multicol}
\usepackage{hyperref}
\title{Study text}
\author{Lukáš Němec}

\usepackage{minted}
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\newminted{cpp}{linenos=true,  bgcolor=bg, xleftmargin=2em, fontsize=\footnotesize}
\newcommand{\codetitle}[1]{\bigskip \noindent {\scriptsize #1}\hrule}


\begin{document} \begin{titlepage} \begin{center} \textsc{\LARGE Study
text}\\[1cm] \textsc{\Large Arduino WSN}\\[0.6cm]


\Large{Lukáš Němec}\\[1cm]

\bigskip
\bigskip

\end{center}
\end{titlepage}



\tableofcontents
\newpage
\section{Introduction}

The purpose of this text is to provide a general introduction to Arduino and applications which can be made using Arduino platform. Focus of a second and third part will be at wireless communication and making wireless sensor networks with Arduino based nodes. All used source codes can be found at Edu-Hoc project home, \url{https://github.com/crocs-muni/Edu-hoc}; at official Arduino website, \url{www.arduino.cc}; or at JeeLib library website, \url{http://jeelabs.net/projects/jeelib/wiki}.

\section{Arduino - general view}
Arduino is an open-source platform and also the phenomenon of last few years. It offers hardware itself and also software for programming ATMega microcontrollers. Thre are not only official Arduino boards but also a large number of clones and derivatives. These are motivated either by cheaper price or by added functionality compared to official ones. The first category  typically includes Chinese clones like Funduino or others, while the second category consists usually of specialized boards like JeeLink and JeeNode USB, which we are going to use.

From all containing Arduino platform, we will use only development environment because our focus will be on ad-hoc networks, we will use specialized boards with a build-in radio module as was mentioned earlier in the text. Nevertheless, we will start with absolute basics of working with Arduino.

    \subsection{Arduino IDE}
    Arduino IDE is a very simple environment for development programs, from a practical point of view, it is just a little bit tweaked text editor with added support for Arduino.
    It supports all major OS, so you can run it on Linux, Windows or OS X. It can run without installation, but this option does not support communication with boards over a serial port. So this option is useful for programming, but if you want to send a program to board itself or communicate with it, then it is highly recommended to install Arduino IDE on your computer.

    You can benefit from this environment also if you decide to use your favorite text editor for actual coding, then Arduino IDE could be used just for compiling the code or because of other tools it offers.
        \paragraph{Installation}
        Installation is not difficult at all. Many Linux distributions will ease the process because Arduino IDE package is usually present in the system repositories. The only thing you should care about is the version of such package, ideally, it should be 1.5 or higher.

        In case of Windows OS, recommended approach is to download installation files directly from official web page \url{http://arduino.cc/en/Main/Software} where you will find executable files, which will either install Arduino IDE on your machine, or just run Arduino IDE itself (in case you do not have access to administrator account on machine you are working).

        If for whatever reason you need to install Arduino IDE some other way (e.g. directly from source code), then all the information you should need is again accessible on official web page \url{http://arduino.cc/en/Main/Software}.
        \paragraph{Tools}
        \subparagraph{Verification}
        One of the most important tools which environment offers is verifier, which sole purpose is to  check for syntax errors of your code. This option is unfortunately not real time, so it is more than recommended to check your syntax once a while.
        \subparagraph{Compilation}
        The second tool is a compiler, which also takes care of upload to the board. Fist you are required to select your version of Arduino board, in some cases board which is the most similar to the one you have (especially important if you have clones or various derivates). Next you should check the port setting and set the port which is the board connected to. In a case of only one board connected, IDE usually selects the right port autonomously, but it is recommended to check it. It is also possible to connect multiple boards at once and then you need to select the right one.

        In a case of issues with detection of the board, it is recommended to restart the whole IDE and try again. Also, it is good practice to connect the board before you start the IDE.

        \subparagraph{Serial monitor}
        Serial monitor is last of the important tools which are useful to know. Although its functionality can be substituted bu any program, which allows communication over a serial port (e.g. PySerial), on the other hand, Serial Monitor is the most accessible tool you have.

        After start, you are required to set up communication frequency (same value as in source code) and then you can read information send from the board or send instructions to the board.

        If you can see characters, which make no sense, it is more than likely, that it is an issue with different setup of frequency on board and Serial Monitor.

    \subsection{Arduino Code basics}
    Arduino can be seen as special case of C language. Almost everything is the same, only thing changed is \texttt{main} function, which is divided into two parts \texttt{setup} and \texttt{loop}. Therefore, you are able to write cycles same as in C language, same for conditions, functions and everything else you might ever need. In addition to this, Arduino adds it's own functions and a large amount of libraries, which are usually targeted to accessory hardware. You can also find many other libraries which make writing the code in C less painful.

        \paragraph{\textbf{\texttt{setup}}}
        As the name suggests, this function is mainly for setup. It is run after the board is powered on and only once. It takes care of initialization of everything you might need. Thus, it is ideal for setup of serial port communication, pin setup and initialization of libraries.

        \paragraph{\textbf{\texttt{loop}}}
        A function which contains the main part of the program and this function can be seen as an infinite cycle. It is called after
        \texttt{setup} function, so we can count on all being initialized. This function will loop until the board is disconnected from power or restarted. It is good practice to write code in this function with respect to infinite loop and also if you need regular check of some event (button pressed) it is recommended to either have code so fast, that checking once a cycle is short enough time frame or run check several times in one run of cycle.\footnote{some boards have dedicated pins for interrupts, which can step into \texttt{loop} function and provide immediate event handling. You can connect special function to the interrupt pin, which takes care of interrupt service}

        \paragraph{Serial}
        One of the most important libraries you will ever encounter. It manages serial port on the side of the board. First you have to initialize it in  \texttt{setup} function, together with frequency setting. Then you can start using it, even immediately after initialization in \texttt{setup} function. All functions from this library has to be called as \texttt{Serial.read()} not just \texttt{read()}.

            \subparagraph{\texttt{print}}
            Basic function for sending data, debugging values and text over a serial port. It is possible to print value itself of format as it is more convenient (e.g. hexadecimal values). Also, it is possible to use \texttt{println}, which in addition sends new line character. When using this function you have to remember, that this function is asynchronous, therefore it sends a return value before it starts to send characters over a serial port.

            You can also use \texttt{write} (for writing binary data) or \texttt{flush} (waits for completion of writing).

            \subparagraph{\texttt{read}}
          Reads data from serial port and returns read value. It is convenient to use together with \texttt{available} function, that returns a number of available bytes on a serial port. You can use this function for sending commands to the board or initial setup, which cannot be hard coded.

\section{WSN node, JeeLib}
Now we look away from general purpose Arduino and aim our focus on wireless communication. We can connect radio module to Arduino board and then we get one node of a wireless network. Or we can take a derivate of Arduino which has radio module already integrated. The radio is the most important part, we do not care much about large amount of pins for other additional components.

One node has not much of a use, it's strength is in large quantities. Nevertheless, it is recommended to get familiarized with just two node network and advanced applications with large amounts of nodes leave for later. With one node you can try communication with computer, use functions from common Arduino libraries and experiment with serial port communication for initial setup.

With two nodes you can experiment with basic radio communication, send, receive messages, and experiment with other functions from JeeLib library.

     \subsection{JeeNode HW }
JeeNode US and JeeLink are Arduino clones; in addition they come with radio module. In contrast to the most common Arduino boards; which are 5V powered; these run on only 3.3V and their components layout is quite a bit different, thus you cannot connect majority of common Arduino accessories (i.e. expansion boards). On top of that, JeeLink is protected with plastic cover, so you cannot really connect anything.

The difference between JeeNode USB and JeeLink is in already mentioned plastic cover and in used USB connector. While JeeNode USB uses mini USB connector, JeeLink uses much more convenient USB type A, which you can connect directly to your computer.

Both versions are based on Arduino mini with ATmega328P processor.\footnote{This is the board you have to select in the Arduino IDE, if you wish to upload code}
JeeLink also contains 16 Mbit of flash memmory, witch can be used for storing application data.

Radio on the board can communicate on three different frequencies, these are 433, 868 or 915 MHz. Frequency is important mainly because of antenna, which can be adjusted for the best performance by selecting the right length for selected frequency, as they are dependent. Although it is important, for most applications you do not need to worry much about it, it will be fine as it is.  JeeLink has frequency set during manufacturing, you can recognize these from color marking on the radio chip. Yellow color means 868 MHz and green color means 433 MHz.\footnote{HW used for lab testbed has frequency set to 868 MHz}
\paragraph{Pins}
  These are contacts, which can be used to connect additional components to the Arduino. It can be anything from simple LED up to light or gravity sensor. These can be connected only to the JeeNode USB.

  \subsection{JeeLib}
    JeeLib is an Arduino library aimed specifically for JeeLink and JeeNode USB nodes and other compatible hardware. It allows us to control radio and few other modules, more information about it can be found directly on project website \url{http://jeelabs.net/projects/jeelib/wiki} or from documentation for the library, which you can obtain in various ways, either generate it yourselves directly from source code you are using with Doxygen tool, or use official documentation available on JeeLabs website \url{http://jeelabs.net/pub/docs/jeelib/}.

    From the content of JeeLib is radio communication the most important part and we can find it under RF12 controller \url{http://jeelabs.net/pub/docs/jeelib/md_intro_rf12.html}. It contains all necessary from initial node setup, message sending and receiving, up to the simple encryption mode.

        \paragraph{How to add to IDE}
        JeeLib requires Arduino IDE version 1.5 and higher, it is not compatible with older versions. It this condition is satisfied, the addition to the IDE is few simple clicks. Fist we have to obtain the library itself, ideally directly from a webpage of JeeLabs \url{http://jeelabs.net/projects/jeelib/wiki}.

        In the menu we can then find \textbf{Sketch} option, Under it is option to \textbf{Import Library} and then we select \textbf{Manage Libraries} (in newer versions of IDE), or \textbf{Add Library} (for older versions). Then it is just a simple task of finding a folder with our downloaded library and its addition. Library can be also added directly in the form of ZIP archive.

        \paragraph{Header format}
        The header is first 8 bits of each message. It contains a type of the message and its sender or recipient. First three bits determine the type of the message, it can either mean if an acknowledgment is required and then distinguishment between unicast and broadcast message. Remaining five bits determine ID of the node, it can either be a recipient, if a node is sending this message, or sender, if node received this message (the change is done by radio driver in the moment of sending the message).

        We have only 5 bits for ID of the node, therefore, we can assign only 32 different node IDs. We assign them in the range 0 to 31 and border values are special dedicated ID. ID 0 is universal for sending out broadcast and a node with ID 31 will receive all messages in the network, without distinguishing its recipient.

        \paragraph{Send unicast message}
        In order to send the message, you fist need to make sure that no other node is transmitting since only one node can transmit a message at given time. JeeLib library makes this relatively easy, because it itself deals with access control.
        It is sufficient to call \texttt{rf12\_canSend()} and result is boolean variable, if we can begin trasmission or not.

        After that we can send message with function \texttt{rf12\_sendStart()} with its parameters (header, payload and payload length). More details to both functions can be found in the documentation. In case of simple application, where we expect small ammount of traffic, we can use \texttt{rf12\_canSend()} in cycle, until the result is positive. Moreover we can simplify this with function \texttt{rf12\_sendNow()} which does exactly the same. Thus it contains waiting cycle and then it sends the message. Parameters are the same as for  \texttt{rf12\_sendStart()}.

        \paragraph{Receive message}
        In order to receive a message we have to periodically (in short intervals) ask with function \texttt{rf12\_recvDone()}, which returns positive answer, in case of incoming message. However, if node receives two or more messages in the interval, then node is able to process only the last one, because message properties are stored in the global variables.

        If the message is received, it is recomended to check for required acknowledgment, and if it is present, then the ideal solution is following condition:

        \codetitle{Example condition for ACK checking}
        \begin{cppcode*}{firstnumber=1}
        if(RF12_WANTS_ACK){
            f12_sendStart(RF12_ACK_REPLY,0,0);
        }
        \end{cppcode*}
        \hrule
        \bigskip

        \paragraph{network with two motes}

\section{WSN network}
    \subsection{Simple apps}
        \paragraph{Alive}
        \paragraph{Sniffer}

    \subsection{Network}
        \paragraph{General options}
        \paragraph{Fixed routing}



\end{document}
